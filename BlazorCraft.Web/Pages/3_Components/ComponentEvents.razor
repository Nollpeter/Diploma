@page "/components/component-events"
@using BlazorCraft.Web.Shared.Examples.Components._2_Events
@using BlazorCraft.Web.Shared.Examples.Components._2_Events.ExampleUsages
@using BlazorCraft.Web.Shared._Exercises.Components._2_Events
@using BlazorCraft.Web.Tests.Components._2_Events

<MudContainer Class="d-grid gap-3">
    <MudText Typo="Typo.h4">Blazor component events</MudText>
    <MudText>In Blazor, component events are the backbone of interactivity within your web application. Think of them as a structured conversation between various parts of your app. For instance, when a user interacts with a component — say, by clicking a button — this component can broadcast a message indicating that the action has taken place.</MudText>
    <MudText>
        Imagine component events as a system of signals and listeners within your web application. When something noteworthy happens within a component, such as a button click or data update, it can emit a signal or event. Other components that are interested in knowing when this event occurs can act as listeners, ready to respond accordingly.
        This system of signaling and listening allows components to communicate effectively, even if they are not directly connected or aware of each other's existence.
    </MudText>
    <MudText>They are beneficial to use, because they make the components more <Important>modular</Important>, <Important>interactive</Important> and <Important>flexible</Important></MudText>

    <MudExpansionPanels MultiExpansion="true">
        <MudExpansionPanelWithStoredState Id="components_eventBinding">
            <TitleContent>
                <MudText Typo="Typo.h5" Class="fw-bold">Event Binding</MudText>
            </TitleContent>
            <ChildContent>
                <div class="d-grid gap-3">
                    <MudText>
                        Event binding is one of the foundational elements for creating interactive user interfaces in Blazor applications.
                        It provides us the ability to bind HTML events directly to C# methods in your component class.
                        This can be achieved via using the @("@onclick"), @("@onkeydown"), etc. attributes in our razor markup
                        We can even pass arguments to the C# method, like event arguments or custom values.
                    </MudText>
                    <MudText>
                        Event binding in Blazor is not just a syntactic sugar; it also plays well with Blazor's rendering system.
                        When an event is triggered and the corresponding C# method is executed, Blazor efficiently re-renders only the component parts that have changed.
                        This makes updates faster and minimizes the performance overhead.
                    </MudText>
                    <MudText>
                        Note that this kind of event binding works on both HTML elements and in blazor components as well.
                        For HTML elements, you can use the standard HTML events along with the @("@") sign to tell Blazor, that the event handler will be a C# method.
                    </MudText>
                    <MudText>
                        Event handlers will be standard C# methods, they can be synchronous and asynchronous as well.
                    </MudText>
                    <AdvancedCodeSnippet TComponent="EventBindingExample" RenderOutput="true"></AdvancedCodeSnippet>
                </div>
                @*TODO Példakód, feladat*@
            </ChildContent>
        </MudExpansionPanelWithStoredState>
        <MudExpansionPanelWithStoredState Id="eventCallBack">
            <TitleContent>
                <MudText Typo="Typo.h5" Class="fw-bold">EventCallBack and EventCallback@("<T>")</MudText>
            </TitleContent>
            <ChildContent>
                <div class="d-grid gap-3">
                    <MudText>
                        The <strong>EventCallback@("<T>")</strong> class is a special Blazor class that can be used to
                        <ul>
                            <li>
                                <MudText>Raise events from a component that can be handled <strong>outside of the component</strong></MudText>
                            </li>
                            <li>
                                <MudText>Pass data for the event handler</MudText>
                            </li>
                            <li>
                                <MudText>Consumed via direct blazor markup</MudText>
                            </li>
                        </ul>
                    </MudText>
                    <MudText>
                        Once declare a public property of type <strong>EventCallback@("<T>")</strong> and annotate with the [Parameter] attribute, we can specify for consuming components in Razor mark-up which method to call when the event is triggered.
                    </MudText>
                    <MudText>
                        <strong>EventCallback</strong> and <strong>EventCallback@("<T>")</strong> will serve us a crucial role in component architecture, particularly in achieving loosely-coupled designs.
                        They provide a way for child components to notify parent components about something that needs their attention.
                        For example, if you have a list component with a delete button for each item, clicking the delete button could trigger an EventCallback that the parent component listens to in order to remove the item from the database.
                    </MudText>
                    <MudText>
                        The <strong>EventCallback@("<T>")</strong> type can also pass data to the consumer component.
                        In this case, declaring the handler in the markup will also have a parameter that can be used in the handler. (See code example below)

                    </MudText>
                    <MudText>
                        The second crucial aspect of EventCallback is its re-rendering behavior.
                        When an EventCallback is triggered, it not only invokes the method it is bound to but also requests a UI refresh of the component that owns the method.
                        This ensures that the parent component's UI is updated based on any state changes that might have occurred as a result of the child component's events.
                    </MudText>
                    <MudText>
                        Raising the event can be achieved via the <strong>InvokeAsync</strong> method.
                        <ul>
                            <li>
                                <MudText>For <strong>EventCallback</strong> this will be a parameterless method</MudText>
                            </li>
                            <li>
                                <MudText>
                                    For <strong>EventCallback@("<T>")</strong> this will be a method with a parameter of type <strong>T</strong>
                                    <br/>
                                    So for <strong>EventCallback@("<int>")</strong> it will be a method with an <strong>int</strong> parameter
                                </MudText>
                            </li>
                        </ul>
                    </MudText>
                    <CompanionSnippets>
                        <Component>
                            <AdvancedCodeSnippet TComponent="EventCallBackExample" RenderOutput="false"></AdvancedCodeSnippet>
                        </Component>
                        <Usage>
                            <AdvancedCodeSnippet TComponent="EventCallBackExampleUsage" RenderOutput="true"></AdvancedCodeSnippet>
                        </Usage>
                    </CompanionSnippets>
                    <MudDivider/>
                    <MudText Class="fw-bold" Typo="Typo.h6">Exercise</MudText>
                    <MudText>Your task here is to create a grid component, that for each item has a delete button, and notifies its consumer component that a grid item was deleted</MudText>
                    <MudText>The actual deletion will be handled externally in the next exercise</MudText>
                    <MudText>In this execrise you will only have to modify the @(nameof(ComponentEvents_Ex2_EventCallBack)).razor component</MudText>
                    <MudText>
                        For the component, you will need
                        <ul>
                            <li>
                                <MudText>A List@("<int") public property annotated with the [Parameter] attribute with the name <strong>@Test_Components_Events_Ex2.EmployeesParameterName</strong></MudText>
                                <MudText>
                                    An EventCallBack@("<ItemWithIndex>") public property annotated with the [Parameter] attribute (The <strong>ItemWithIndex</strong> type will be provided, you only need to use it)
                                    with the name <strong>ListItemDeleted</strong>
                                </MudText>
                            </li>
                        </ul>
                    </MudText>
                    <MudText>You only have to render grid rows, you will be guided by the table header, how a row should look like</MudText>
                    <MudText><strong>Note:</strong> valid table rows look like this inside the @("tbody") tag</MudText>
                    <CodeSnippet>
                        @("<tr> \n" +
                          "    <td>...</td> \n" +
                          "    <td>...</td> \n" +
                          "    ... \n" +
                          "</tr> \n")
                    </CodeSnippet>
                    <MudText></MudText>
                    <TestRunner TTestClass="Test_Components_Events_Ex2"></TestRunner>
                </div>
            </ChildContent>
        </MudExpansionPanelWithStoredState>
        <MudExpansionPanelWithStoredState Id="components_ex-final">
            <TitleContent>
                <MudText Typo="Typo.h5" Class="fw-bold">Exercise</MudText>
            </TitleContent>
            <ChildContent>
                <div class="d-grid gap-3">
                    <MudText>
                        Your task is to modify the pre-created component: @(nameof(ComponentEvents_ExLessonFinal)).razor, so that it behaves accordingly:
                        <ul>
                            <li>
                                <MudText>
                                    The component should handle the @Test_Components_Events_Ex2.EventCallBackPropertyName event,
                                    so that the list items are deleted from the @Test_Components_Events_ExLessonFinal.EmployeesParameterName list
                                </MudText>
                            </li>
                            <li>
                                <MudText>
                                    The component should also list the already deleted employees, you will find the instructions inside the component how you need to render them
                                </MudText>
                            </li>
                        </ul>
                    </MudText>
                    <MudText>You can see that you have some code already provided for you, you don't need to touch them, also, please don't!</MudText>
                    <MudText>The component also guides you with comments where you need to put your code, please follow these instructions</MudText>
                    <TestRunner TTestClass="Test_Components_Events_ExLessonFinal"></TestRunner>
                </div>
            </ChildContent>
        </MudExpansionPanelWithStoredState>
    </MudExpansionPanels>
    <ComponentEvents_ExLessonFinal></ComponentEvents_ExLessonFinal>
</MudContainer>


@code {

}